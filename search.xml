<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/09/19/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo<i class="fas fa-external-link-alt"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation<i class="fas fa-external-link-alt"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting<i class="fas fa-external-link-alt"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub<i class="fas fa-external-link-alt"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo命令</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode9-23</title>
    <url>/2022/09/23/leetcode9-23/</url>
    <content><![CDATA[<h2 id="leetcode每日一天（9-23）"><a href="#leetcode每日一天（9-23）" class="headerlink" title="leetcode每日一天（9.23）"></a>leetcode每日一天（9.23）</h2><p><a class="link"   href="https://leetcode.cn/problems/design-linked-list/" >707. 设计链表<i class="fas fa-external-link-alt"></i></a><br>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：<code>val</code> 和 <code>next</code>。<code>val</code> 是当前节点的值，<code>next</code> 是指向下一个节点的指针&#x2F;引用。如果要使用双向链表，则还需要一个属性 <code>prev</code> 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。<br>在链表类中实现这些功能：</p>
<ol>
<li>get(index)：获取链表中第<code>index</code>个节点的值。如果索引无效，则返回-1。</li>
<li>addAtHead(val)：在链表的第一个元素之前添加一个值为 <code>val</code> 的节点。插入后，新节点将成为链表的第一个节点。</li>
<li>addAtHead(val)：在链表的第一个元素之前添加一个值为<code> val</code> 的节点。插入后，新节点将成为链表的第一个节点。</li>
<li>addAtIndex(index,val)：在链表中的第<code> index </code>个节点之前添加值为<code> val</code>  的节点。如果<code> index </code>等于链表的长度，则该节点将附加到链表的末尾。如果 <code>index</code> 大于链表长度，则不会插入节点。如果<code>index</code>小于0，则在头部插入节点。</li>
<li>deleteAtIndex(index)：如果索引<code>index</code>有效，则删除链表中的第 <code>index</code> 个节点。</li>
</ol>
<h6 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MyLinkedList linkedList = new MyLinkedList();</span><br><span class="line">linkedList.addAtHead(1);</span><br><span class="line">linkedList.addAtTail(3);</span><br><span class="line">linkedList.addAtIndex(1,2);   //链表变为1-&gt; 2-&gt; 3</span><br><span class="line">linkedList.get(1);            //返回2</span><br><span class="line">linkedList.deleteAtIndex(1);  //现在链表是1-&gt; 3</span><br><span class="line">linkedList.get(1);            //返回3</span><br></pre></td></tr></table></figure>
<h6 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">所有val值都在 [1, 1000] 之内。</span><br><span class="line">操作次数将在  [1, 1000] 之内。</span><br><span class="line">请不要使用内置的 LinkedList 库。</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h6 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h6><p>这是一道水题目，主要是用到数据结构里面的链表，我是用的c++里面的ListNode来解答这题比较轻松。题目要求有三处增加函数，实质上在首部添加数值和在尾部添加数值的操作可以归纳为addAtIndex，则我们在addAtHead和addAtTail可以直接调用addAtIndex用来减少我们的代码量。</p>
<h6 id="ListNode的结构："><a href="#ListNode的结构：" class="headerlink" title="ListNode的结构："></a>ListNode的结构：</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct ListNode &#123;</span><br><span class="line">      int val;  //当前结点的值</span><br><span class="line">      ListNode *next;  //指向下一个结点的指针</span><br><span class="line">      ListNode(int x) : val(x), next(NULL) &#123;&#125;  //初始化当前结点值为x,指针为空</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">ListNode *p=new ListNode(0); //新增一个节点</span><br><span class="line">delete p; //删除一个节点，释放内存</span><br></pre></td></tr></table></figure>
<h6 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class MyLinkedList &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="function"><span class="title">MyLinkedList</span></span>() &#123;</span><br><span class="line">        this-&gt;size = 0;</span><br><span class="line">        this-&gt;<span class="built_in">head</span> = new ListNode(0); //首节点，值无意义</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int get(int index) &#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;0||index&gt;=size)</span><br><span class="line">            <span class="built_in">return</span> -1;</span><br><span class="line">        ListNode *cur = <span class="built_in">head</span>;</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt;= index; i++) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> cur-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void addAtHead(int val) &#123;</span><br><span class="line">        addAtIndex(0, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void addAtTail(int val) &#123;</span><br><span class="line">        addAtIndex(size,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void addAtIndex(int index, int val) &#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;size)</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        index=max(0,index);</span><br><span class="line">        ListNode *cur=<span class="built_in">head</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;index;i++)</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        ListNode *toAdd = new ListNode(val);</span><br><span class="line">        toAdd-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = toAdd;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void deleteAtIndex(int index) &#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;0||index&gt;=size)</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        ListNode *cur=<span class="built_in">head</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;index;i++)</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        ListNode *p = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        delete p;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int size;</span><br><span class="line">    ListNode *<span class="built_in">head</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MyLinkedList object will be instantiated and called as such:</span><br><span class="line"> * MyLinkedList* obj = new MyLinkedList();</span><br><span class="line"> * int param_1 = obj-&gt;get(index);</span><br><span class="line"> * obj-&gt;addAtHead(val);</span><br><span class="line"> * obj-&gt;addAtTail(val);</span><br><span class="line"> * obj-&gt;addAtIndex(index,val);</span><br><span class="line"> * obj-&gt;deleteAtIndex(index);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode9.20</title>
    <url>/2022/09/20/leetcode9-20/</url>
    <content><![CDATA[<h2 id="leetcode每日一天（9-20）"><a href="#leetcode每日一天（9-20）" class="headerlink" title="leetcode每日一天（9.20）"></a>leetcode每日一天（9.20）</h2><p><a class="link"   href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/" >题目：698. 划分为k个相等的子集<i class="fas fa-external-link-alt"></i></a><br>给定一个整数数组  nums 和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。</p>
<h6 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4</span><br><span class="line">输出： True</span><br><span class="line">说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。</span><br></pre></td></tr></table></figure>
<h6 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,2,3,4], k = 3</span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h6 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 &lt;= k &lt;= len(nums) &lt;= 16</span><br><span class="line">0 &lt; nums[i] &lt; 10000</span><br><span class="line">每个元素的频率在 [1,4] 范围内</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h6 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h6><p>我们可以把每个集合看做一个桶，然后我们可以通过dfs和剪枝来模拟每个数值入桶和出桶。</p>
<h6 id="剪枝："><a href="#剪枝：" class="headerlink" title="剪枝："></a>剪枝：</h6><p>因为我们需要有k个桶且每个桶的值是相等的。以此可以推出给定的值相加一定是桶的值的倍速，并且不会存在比桶值大的数值。最关键的剪枝为，我们在dfs遍历一个桶是否可以装满，如果回溯的时候发现这个桶回到了初始值，则证明这个桶是装不满的。然而，每个桶都是一样的，这个桶装不满则其他桶一样装不满。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bool canPartitionKSubsets(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">    int <span class="built_in">sum</span>=0,size=nums.size();</span><br><span class="line">    int maxN=-1;</span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;size;i++)</span><br><span class="line">        <span class="built_in">sum</span>+=nums[i],maxN=max(maxN,nums[i]);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sum</span>%k!=0||maxN&gt;<span class="built_in">sum</span>/k)</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">sum</span>=<span class="built_in">sum</span>/k;</span><br><span class="line">    <span class="built_in">sort</span>(nums.begin(), nums.end());</span><br><span class="line">  //  cout&lt;&lt;<span class="string">nums[0];</span></span><br><span class="line"><span class="string">    vector&lt;int&gt; arr(k,sum);</span></span><br><span class="line"><span class="string">    bool t=false;</span></span><br><span class="line"><span class="string">    t=dfs(nums</span>,arr,size-1,k,size,<span class="built_in">sum</span>);</span><br><span class="line">    <span class="built_in">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">//nums给定数组 arr模拟每一个桶  cur以此遍历每个数值 k一共有几个桶 size原数组大小 <span class="built_in">sum</span>每个桶的值</span><br><span class="line">bool dfs(vector&lt;int&gt;&amp; nums,vector&lt;int&gt;&amp; arr,int cur,int k,int size,int <span class="built_in">sum</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur &lt; 0)&#123;</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;k;i++)</span><br><span class="line">            <span class="keyword">if</span>(arr[i]!=0)</span><br><span class="line">                <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;k;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]-nums[cur]&lt;nums[0]&amp;&amp;arr[i]!=nums[cur])</span><br><span class="line">            <span class="built_in">continue</span>;</span><br><span class="line">        arr[i] -= nums[cur];</span><br><span class="line">        // <span class="keyword">for</span>(int j=0;j&lt;k;j++)</span><br><span class="line">        //     cout&lt;&lt;<span class="string">arr[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="string">        // cout&lt;&lt;endl;</span></span><br><span class="line"><span class="string">        if(dfs(nums,arr</span>,cur-1,k,size,<span class="built_in">sum</span>))</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">        arr[i] += nums[cur];</span><br><span class="line">        <span class="keyword">if</span>(arr[i]==<span class="built_in">sum</span>)</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo增添评论区</title>
    <url>/2022/09/22/newComment/</url>
    <content><![CDATA[<p>hexo有三种新增评论的模板分别是：valine、gitalk还有twikoo。我使用的是twikoo。</p>
<h2 id="Twikoo"><a href="#Twikoo" class="headerlink" title="Twikoo"></a>Twikoo</h2><p>Twikoo是一个静态博客评论系统，除了评论功能，还可以记录文章阅读量。搭建过程包括准备数据库和云函数，还有修改主题配置文件。<br>而配置Twikoo主要是分两种一种是使用腾讯云来布置，一种是使用Mongodb+Vercel部署。</p>
<h3 id="腾讯云部署"><a href="#腾讯云部署" class="headerlink" title="腾讯云部署"></a>腾讯云部署</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>注册<a class="link"   href="https://curl.qcloud.com/KnnJtUom" >云开发CloudBase(opens new window)<i class="fas fa-external-link-alt"></i></a><br>进入<a class="link"   href="https://console.cloud.tencent.com/tcb/" >云开发控制台 (opens new window)<i class="fas fa-external-link-alt"></i></a>，新建环境，请按个人需要配置#### 环境</p>
<ol>
<li>进入后选择空模板</li>
<li>安全配置：再登录授权中启用“匿名登录”</li>
<li>选择安全配置，将网站域名添加到“WEB安全域名”</li>
<li>进入环境总览中复制环境id（后面要用)</li>
</ol>
<h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><p>我们一般选择手动部署</p>
<ol>
<li>新建函数，函数名称填写：<code>twikoo</code>，创建方式选择：<code>空白函数</code>，运行环境选择：<code>Nodejs 10.15</code>（选择最靠近你的运行环境的版本），函数内存请选择：<code>128MB</code></li>
<li>点击下一步，修改函数代码：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">exports.main = require(<span class="string">&#x27;twikoo-func&#x27;</span>).main</span><br></pre></td></tr></table></figure></li>
<li>确定完成后，点击刚才创建的twikoo函数，点击函数代码，创建<code> package.json</code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123; <span class="string">&quot;dependencies&quot;</span>: &#123; <span class="string">&quot;twikoo-func&quot;</span>: <span class="string">&quot;1.4.9&quot;</span> &#125; &#125;</span><br></pre></td></tr></table></figure>
twikoo-func填写最新的版本</li>
</ol>
<h4 id="命令行环境部署"><a href="#命令行环境部署" class="headerlink" title="命令行环境部署"></a>命令行环境部署</h4><p>以下操作部署，可使用任意环境面板部署，这里使用的是git进行部署</p>
<ol>
<li>克隆本仓库<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/imaegoo/twikoo.git</span><br><span class="line"><span class="built_in">cd</span> twikoo</span><br></pre></td></tr></table></figure></li>
<li>安装依赖项<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g yarn <span class="comment"># 已安装 yarn 可以跳过此步</span></span><br><span class="line">yarn install</span><br></pre></td></tr></table></figure></li>
<li>授权云开发环境（会自动跳转到授权界面，点击授权即可）<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn run login</span><br></pre></td></tr></table></figure></li>
<li>自动部署<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn deploy -e 您的环境<span class="built_in">id</span> (就是之前你复制的)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="在-Hexo-中使用"><a href="#在-Hexo-中使用" class="headerlink" title="在 Hexo 中使用"></a>在 Hexo 中使用</h4><ol>
<li>在主题的配置文件中找到comment<br>enable改为true，use为twikoo<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">comment:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  use: twikoo <span class="comment"># values: valine | gitalk | twikoo</span></span><br></pre></td></tr></table></figure></li>
<li>继续往下找寻 twikoo<br>region一定要填写<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">twikoo:</span><br><span class="line">  env_id:  填写你的环境iD  <span class="comment">#https://www.sunset148.top/ Tencent Cloud environment id</span></span><br><span class="line">  region: ap-shanghai <span class="comment"># environment region. If select Guangzhou, fill in &quot;ap-guangzhou&quot;.</span></span><br></pre></td></tr></table></figure>
到这里在腾讯云的配置就结束了</li>
</ol>
<hr>
<h3 id="Mongodb-Vercel部署"><a href="#Mongodb-Vercel部署" class="headerlink" title="Mongodb+Vercel部署"></a>Mongodb+Vercel部署</h3><h4 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h4><p>我们使用MongoDB存储数据</p>
<ol>
<li><a class="link"   href="https://www.mongodb.com/zh-cn/cloud/atlas/register" >注册MongoDB账号<i class="fas fa-external-link-alt"></i></a></li>
<li>创建免费数据库，类型选择<code>Shared</code>，区域选择 <code>AWS / N. Virginia (us-east-1)</code> </li>
<li>点击<code>Connect</code>按钮，键入 0.0.0.0&#x2F;0 以允许所有 IP 地址的连接，并创建数据库用户</li>
<li>连接方式选择中间的<code>Connect your application</code></li>
<li>记录下连接字符串，等下使用时记得将其中的 <password> 修改为刚刚设置的用户密码（<password>需要整体替换）</li>
</ol>
<h4 id="Vercel"><a href="#Vercel" class="headerlink" title="Vercel"></a>Vercel</h4><ol>
<li>使用<code>Vercel</code>来运行云函数，先注册 <a class="link"   href="https://vercel.com/signup" >vercel 账号<i class="fas fa-external-link-alt"></i></a>，可以选择从<code>GitHub</code>之类的登录，也可以选择通过邮箱注册</li>
<li>新创建一个库来保存代码（如果你之前用使用该<a class="link"   href="https://twikoo.js.org/quick-start.html#vercel-%E9%83%A8%E7%BD%B2" >链接<i class="fas fa-external-link-alt"></i></a>）</li>
<li>完成后，在导航栏选择<code>Setting</code>，在左侧选择<code>Environment Variables</code>，添加变量<code>MONGODB_URI</code>，值输入刚才的连接字符串，记得修改 <code>&lt;password&gt;</code> 为数据库用户密码</li>
<li>导航栏中选择<code>Deployments</code>，重新部署一下</li>
<li>回到<code>Overview</code>，可以看见<code>云函数运行正常</code>字样，在右边的<code>域名（DOMAINS）</code>里挑一个记录下你的域名,而该域名就是你的环境ID</li>
</ol>
<h5 id="Tip："><a href="#Tip：" class="headerlink" title="Tip："></a>Tip：</h5><p>因为 Vercel.app 可能在国内被墙，所以可能需要手动添加一个自己域名。<br>但是解决方法也很简单——准备一个新域名，然后把这个域名指过去</p>
<ol>
<li>来到 <code>vercel</code> 控制台，点进去你的实例</li>
<li>找到 <code>Setting</code> -&gt; <code>Domain</code></li>
<li>手动添加你的域名进去</li>
<li>他会给出解析配置，你就去改你的域名解析就好了（在你购买域名的官网会有一个域名解析）</li>
<li>最后去主题配置文件里更新这个新地址就行</li>
</ol>
<h4 id="主题文件配置"><a href="#主题文件配置" class="headerlink" title="主题文件配置"></a>主题文件配置</h4><p>在主题文件中找到配置文件keep\layout_partial\comment</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">twikoo:</span><br><span class="line">  env_id:  你的域名  <span class="comment">#https://www.sunset148.top/ Tencent Cloud environment id</span></span><br><span class="line">  region: ap-shanghai <span class="comment"># environment region. If select Guangzhou, fill in &quot;ap-guangzhou&quot;.</span></span><br></pre></td></tr></table></figure>
<p>重启Hexo，就能可以看到了。</p>
<hr>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>但很有可能你的评论系统打不开，很有可能是因为<code>Butterfly</code>版本过低的问题。<br>博主试了几个Butterfly依旧开不开评论系统，转而投向了keep</p>
<h5 id="keep安装"><a href="#keep安装" class="headerlink" title="keep安装"></a>keep安装</h5><p>如果你在使用 Hexo 5.0 或更高版本，最简单的安装方式是通过 npm：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> hexo-site</span><br><span class="line">$ npm install hexo-theme-keep</span><br></pre></td></tr></table></figure>
<p>或者使用 git 克隆整个仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> hexo-site</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/XPoet/hexo-theme-keep themes/keep</span><br></pre></td></tr></table></figure>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>安装完成后，在 Hexo 配置文件中将<code>theme</code>设置为<code> keep</code>。<br>Keep 不定期发布新版本，你可以通过如下命令更新 Keep。</p>
<h5 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h5><p>通过 npm 安装最新版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> hexo-site</span><br><span class="line">$ npm update hexo-theme-keep</span><br></pre></td></tr></table></figure>
<p>通过 git 更新到最新的 master 分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> themes/keep</span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure>
<h5 id="Twikoo-1"><a href="#Twikoo-1" class="headerlink" title="Twikoo"></a>Twikoo</h5><p>另外在keep里面的keep\layout_partial\comment的twikoo.ejs里面的版本号更改为最新的就是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;script &lt;%= theme.pjax.enable === <span class="literal">true</span> ? <span class="string">&#x27;data-pjax&#x27;</span> : <span class="string">&#x27;&#x27;</span> %&gt;                src=<span class="string">&quot;//cdn.jsdelivr.net/npm/twikoo@1.6.7/dist/twikoo.all.min.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><a class="link"   href="https://keep-docs.xpoet.cn/usage-tutorial/quick-start.html" >keep官方文档<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>hexo新增评论区</tag>
      </tags>
  </entry>
  <entry>
    <title>博客新增了搜索、分类还有标签功能</title>
    <url>/2022/09/23/newHexoSomeFunction/</url>
    <content><![CDATA[<p>今天为博客新增了搜索、分类还有标签功能</p>
<h2 id="搜索功能添加"><a href="#搜索功能添加" class="headerlink" title="搜索功能添加"></a>搜索功能添加</h2><p>本文主要描述了怎么添加hexo博客搜索插件，然后启动搜索功能，对两个本地搜索插件的使用进行了描述，文章可能还有很多不足，请大家谅解，欢迎大佬提意见。</p>
<h3 id="本文用的东西"><a href="#本文用的东西" class="headerlink" title="本文用的东西"></a>本文用的东西</h3><ol>
<li>hexo</li>
<li>电脑</li>
</ol>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><h4 id="插件比较"><a href="#插件比较" class="headerlink" title="插件比较"></a>插件比较</h4><p>“hexo-generator-searchdb”插件功能比较强大，可以替代后面讲的第二个插件“hexo-generator-json-content”插件。而“hexo-generator-json-content”插件只能生产json文件，且不能定义文件名，无法替代“hexo-generator-searchdb”插件，但是“hexo-generator-json-content”可以定义生成的json文件的格式。</p>
<h4 id="hexo-generator-searchdb插件"><a href="#hexo-generator-searchdb插件" class="headerlink" title="hexo-generator-searchdb插件"></a>hexo-generator-searchdb插件</h4><h5 id="插件原理"><a href="#插件原理" class="headerlink" title="插件原理"></a>插件原理</h5><p>这个插件会扫描博客文章，根据“——config.yml”的配置从文章里获取内容生成一个xml&#x2F;json文件的结果，类似于博客中文章信息的摘要把，搜索的时候就搜索这个文件的内容。</p>
<h5 id="添加插件"><a href="#添加插件" class="headerlink" title="添加插件"></a>添加插件</h5><ol>
<li>打开<code>cmd</code></li>
<li>输入以下命令添加博客搜索插件。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//未配置淘宝的数据源</span><br><span class="line">npm install hexo-generator-searchdb --save</span><br><span class="line">//配置淘宝数据源的可以使用这条命令，网络会好一些</span><br><span class="line">cnpm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></li>
<li>打开博客目录，找到<code>_config.yml</code>文件，添加以下内容。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  content: <span class="literal">true</span></span><br><span class="line">  format: html</span><br></pre></td></tr></table></figure>
<code>path</code>：表示搜索后生成的文件路径，可以生成xml和json两种格式；将path设置为<code>content.json</code>就可以替代第二个插件。<br><code>field</code>：表示搜索的范围，有<code>post</code>、<code>page</code>和<code>all</code>三种值。<br>    <code>post</code>：所有的文章；<br>    <code>page</code>：所有顶部导航选项的页面；<br>    <code>all</code>：所有的文章和顶部导航选项的页面。<br><code>content</code>：是否包含搜索到的文章的全部内容。如果<code>false</code>，生成的结果只包括标题和创建时间这些信息，没有文章主体。默认情况下是<code>true</code>.<br><code>format</code>：搜索到的内容、选项的格式。<br>    <code>html</code>(默认)：将html原文本缩略。<br>    <code>striptags</code>：将html原文本缩略，并删除所有标记。<br>    <code>raw</code>：记下每一篇文章或每一页的文字。</li>
</ol>
<h5 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h5><p>打开博客目录目录，找到当前正在使用的主题的<code>_config.yml</code>文件，打开进行编辑，找到<code>local_search</code>，修改<code>enable</code>的值为<code>true</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本地搜索</span></span><br><span class="line">local_search:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>到此即可使用搜索功能了</p>
<hr>
<h2 id="分类、标签和留言功能添加"><a href="#分类、标签和留言功能添加" class="headerlink" title="分类、标签和留言功能添加"></a>分类、标签和留言功能添加</h2><p>这三个功能实际上是异曲同工的。使用类似的方法即可添加</p>
<h4 id="新建标签页"><a href="#新建标签页" class="headerlink" title="新建标签页"></a>新建标签页</h4><p>用命令行新建一个页面：（页面名称可以任意）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page <span class="string">&quot;tages&quot;</span> </span><br></pre></td></tr></table></figure>
<h4 id="设置其类型-type-值为“tages”"><a href="#设置其类型-type-值为“tages”" class="headerlink" title="设置其类型 type 值为“tages”"></a>设置其类型 type 值为“tages”</h4><p>用命令行新建一个页打开 &#x2F;source&#x2F;tages&#x2F;index.md，设置其类型<code>type</code>值为<code>tages</code>：（页面名称可以任意）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title: tags</span><br><span class="line"><span class="built_in">date</span>: 2019-07-26 00:33:58</span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;tags&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果需要多个标签或者分类的话</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- 分类</span><br><span class="line">- 子分类</span><br><span class="line">- 子子分类</span><br><span class="line">tags:</span><br><span class="line">- 标签1</span><br><span class="line">- 标签2</span><br></pre></td></tr></table></figure>
<h4 id="在主题的配置文件更改"><a href="#在主题的配置文件更改" class="headerlink" title="在主题的配置文件更改"></a>在主题的配置文件更改</h4><p>打开 &#x2F;themes&#x2F;主题&#x2F;_config.yml，把tages标签那项取消注释即可，下面的是已经取消注释了的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  主页: /</span><br><span class="line">  <span class="comment">#随笔: /tags/随笔/</span></span><br><span class="line">  <span class="comment">#分类: /categories</span></span><br><span class="line">  <span class="comment">#归档: /archives</span></span><br><span class="line">  标签: /tags</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>hexo搜索</tag>
        <tag>hexo分类、标签和留言墙</tag>
      </tags>
  </entry>
  <entry>
    <title>遥感影像的路网识别、提取的数据集</title>
    <url>/2022/09/29/roadDataset/</url>
    <content><![CDATA[<h3 id="Massachusetts-建筑"><a href="#Massachusetts-建筑" class="headerlink" title="Massachusetts-建筑"></a>Massachusetts-建筑</h3><h5 id="数据集详细情况"><a href="#数据集详细情况" class="headerlink" title="数据集详细情况"></a>数据集详细情况</h5><p>项目简介：麻萨诸塞州的航空影像，协助机器学习航空影像标签,包括了建筑和道路的影像与标签文件。本文我们介绍其中的建筑数据集。<br>数据介绍：马萨诸塞州建筑物数据集由波士顿地区的 151 张航拍图像组成，每张图像的大小为 1500 × 1500 像素，面积为 2.25 平方公里。因此，整个数据集大约覆盖 340 平方公里。我们将数据随机分成 137 张图像的训练集、10 张图像的测试集和 4 张图像的验证集。目标地图是通过栅格化从 OpenStreetMap 项目获得的建筑物覆盖区获得的。这些数据仅限于平均遗漏噪声水平约为 5% 或更低的区域。之所以能够收集到如此大量的高质量建筑足迹数据，是因为波士顿市为 OpenStreetMap 项目贡献了整个城市的建筑足迹。该数据集主要涵盖城市和郊区，各种规模的建筑物，包括个人房屋和车库，都包含在标签中。</p>
<h5 id="数据集下载地址"><a href="#数据集下载地址" class="headerlink" title="数据集下载地址"></a>数据集下载地址</h5><p>项目地址：<a class="link"   href="https://www.cs.toronto.edu/~vmnih/data/" >https://www.cs.toronto.edu/~vmnih/data/<i class="fas fa-external-link-alt"></i></a><br>数据集下载： 链接： <a class="link"   href="https://pan.baidu.com/s/1Y9yk8P26TGpxmiCsYSjfHw" >https://pan.baidu.com/s/1Y9yk8P26TGpxmiCsYSjfHw<i class="fas fa-external-link-alt"></i></a><br>           提取码：zfal</p>
<p>出处：<a class="link"   href="https://blog.csdn.net/u014311125/article/details/121627540?spm=1001.2014.3001.5501" >(44条消息) 遥感影像公开数据集:Massachusetts-建筑_GHZhao_GIS_RS的博客-CSDN博客_massachusetts道路数据集<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="CHN6-CUG-Road-Dataset"><a href="#CHN6-CUG-Road-Dataset" class="headerlink" title="CHN6-CUG Road Dataset"></a>CHN6-CUG Road Dataset</h3><h5 id="数据集详细情况-1"><a href="#数据集详细情况-1" class="headerlink" title="数据集详细情况"></a>数据集详细情况</h5><p>CHN6-CUG Road Dataset是中国代表性城市的新型大型卫星图像数据集。其遥感影像底图来自谷歌地球。选取了6个城市化程度、城市规模、发展程度、城市结构、历史文化程度不同的城市，包括北京朝阳区、上海杨浦区、武汉市中心、深圳南山区、香港沙田地区、澳门。研究区域如图1所示。标记道路由有盖道路和无盖道路组成，具体取决于道路覆盖程度。根据地理因素的物理观点，标记道路包括铁路、高速公路、城市道路和农村道路等。<br>CHN6-CUG 包含 4511 张 512×512 大小的标记图像，分为 3608 张用于模型训练的图像和 903 张用于测试和结果评估的图像，分辨率为 50 厘米&#x2F;像素。原始数据集采用.jpg格式，道路标记图采用.png格式。压缩的数据量为 175MB。<br>CHN6-CUG 道路数据集中研究区域的概述<br>中国化学烷基化学道路数据集样本</p>
<h5 id="数据集下载地址-1"><a href="#数据集下载地址-1" class="headerlink" title="数据集下载地址"></a>数据集下载地址</h5><p>数据集下载：  链接：<a class="link"   href="https://pan.baidu.com/share/init?surl=hHwUfwGvqb_5kM-3dpyM_g" >百度网盘 请输入提取码 (baidu.com)<i class="fas fa-external-link-alt"></i></a><br>提取码：urs6</p>
<p>出处：<a class="link"   href="http://grzy.cug.edu.cn/zhuqiqi/zh_CN/yjgk/32368/list/index.htm" >朱祺琪 中文主页 公开数据共享 中国地质大学（武汉）教师个人主页系统 (cug.edu.cn)<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="SOS-Deep-SAR-Oil-Spill-Dataset"><a href="#SOS-Deep-SAR-Oil-Spill-Dataset" class="headerlink" title="SOS: Deep-SAR Oil Spill Dataset"></a>SOS: Deep-SAR Oil Spill Dataset</h3><h5 id="数据集详细情况-2"><a href="#数据集详细情况-2" class="headerlink" title="数据集详细情况"></a>数据集详细情况</h5><p>SOS 数据集有两个研究区域：墨西哥湾漏油区和波斯湾漏油区。图1显示了墨西哥湾漏油的位置以及所选ALOS卫星图像的典型子集。图2给出了波斯湾漏油的位置和选定的Sentinel-1A卫星图像的典型子集。因此，使用数据增强技术来扩展原始数据集。裁剪、旋转、添加杂色和其他操作都在原始灰度地图上进行。最后，共使用了来自墨西哥石油泄漏地区的3101张图像进行训练，776张图像用于测试。共有3354张来自波斯湾漏油区的图像用于训练，839张图像用于测试。<br>图例.1. 墨西哥湾漏油的位置。（a）4月25日拍摄的NASA &#x2F;MODIS卫星图像，显示了深水地平线灾难的浮油。（资料来源：约翰·阿莫斯 2010 [1]）（b） 选定的“海洋法”卫星图像的典型子集。<br>图例.2. 波斯湾漏油的位置。（a） Sentinel-2多光谱卫星图像显示，2017年8月11日，浮油在科威特海岸的Al Khiran附近登陆。（资料来源：约翰·阿莫斯 2017 [2]）。（b） 选定的哨兵-1A卫星图像的典型子集。</p>
<h5 id="数据集下载地址-2"><a href="#数据集下载地址-2" class="headerlink" title="数据集下载地址"></a>数据集下载地址</h5><p>数据集下载：  <a class="link"   href="https://pan.baidu.com/share/init?surl=TcbtGt7qp-IL0dALQ9HBlg" >链接：百度网盘 请输入提取码 (baidu.com)<i class="fas fa-external-link-alt"></i></a><br>提取码：urs6<br>出处：<a class="link"   href="http://grzy.cug.edu.cn/zhuqiqi/zh_CN/yjgk/32368/list/index.htm" >朱祺琪 中文主页 公开数据共享 中国地质大学（武汉）教师个人主页系统 (cug.edu.cn)<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="DeepGlobe-道路提取数据集"><a href="#DeepGlobe-道路提取数据集" class="headerlink" title="DeepGlobe 道路提取数据集"></a>DeepGlobe 道路提取数据集</h3><h5 id="数据集详细情况-3"><a href="#数据集详细情况-3" class="headerlink" title="数据集详细情况"></a>数据集详细情况</h5><p>Road Challenge 的训练数据包含 6226 张 RGB 卫星图像，大小为 1024x1024。<br>该图像具有 50 厘米像素分辨率，由 DigitalGlobe 的卫星收集。<br>该数据集包含 1243 个验证图像和 1101 个测试图像（但没有掩码）。<br>标签<br>每个卫星图像都与道路标签的蒙版图像配对。蒙版是灰度图像，白色代表道路像素，黑色代表背景。<br>卫星图像和相应蒙版图像的文件名是id _sat.jpg 和id _mask.png。id是一个随机整数。<br>请注意：遮罩图像的值可能不是纯0和255，转换为标签时，请在阈值128处进行二值化。<br>由于注释分割掩码的成本，标签并不完美，特别是在农村地区。此外，我们故意没有标注农田内的小路。</p>
<h5 id="数据集下载地址-3"><a href="#数据集下载地址-3" class="headerlink" title="数据集下载地址"></a>数据集下载地址</h5><p>数据集下载：  链接：<br><a class="link"   href="https://bj.bcebos.com/ai-studio-online/bae42d32d39b46059783791e327bea12b2716d64cf654be08aa0c11bd670ef21?authorization=bce-auth-v1/5cfe9a5e1454405eb2a975c43eace6ec/2022-09-04T15:26:45Z/-1//3dc55e6d32d46b7c21406ee098d7c08c1eeba23e90082aa3da9a0b140abbc87d&amp;responseContentDisposition=attachment;%20filename=DeepGlobe.zip" >https://bj.bcebos.com/ai-studio-online/bae42d32d39b46059783791e327bea12b2716d64cf654be08aa0c11bd670ef21?authorization=bce-auth-v1%2F5cfe9a5e1454405eb2a975c43eace6ec%2F2022-09-04T15%3A26%3A45Z%2F-1%2F%2F3dc55e6d32d46b7c21406ee098d7c08c1eeba23e90082aa3da9a0b140abbc87d&amp;responseContentDisposition=attachment%3B%20filename%3DDeepGlobe.zip<i class="fas fa-external-link-alt"></i></a><br>出处：<a class="link"   href="https://aistudio.baidu.com/aistudio/datasetdetail/102399" >DeepGlobe 道路提取数据集 - 飞桨AI Studio (baidu.com)<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Leveraging-Crowdsourced-GPS-Data-for-Road-Extraction-from-Aerial-Imagery"><a href="#Leveraging-Crowdsourced-GPS-Data-for-Road-Extraction-from-Aerial-Imagery" class="headerlink" title="Leveraging Crowdsourced GPS Data for Road Extraction from Aerial Imagery"></a>Leveraging Crowdsourced GPS Data for Road Extraction from Aerial Imagery</h3><h5 id="数据集详细情况-4"><a href="#数据集详细情况-4" class="headerlink" title="数据集详细情况"></a>数据集详细情况</h5><p>GPS 数据集包含从北京约 280000 辆汽车收集的约 50 米行 GPS 记录。<br>数据集下载地址<br>数据集下载：  为了节省加载时间，我们以Python的Pickle格式发布数据集，可以直接加载，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas</span><br><span class="line">import pickle</span><br><span class="line">gps_data = pickle.load(open(<span class="string">&#x27;beijing_gps_dir_speed_interval_sorted.pkl&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>出处：1.<a class="link"   href="https://github.com/suniique/Leveraging-Crowdsourced-GPS-Data-for-Road-Extraction-from-Aerial-Imagery" >suniique&#x2F;利用-众包-GPS-用于从航空图像中提取道路的数据：CVPR 2019年论文“利用众包GPS数据从航空图像中提取道路”的源代码 (github.com)<i class="fas fa-external-link-alt"></i></a><br>2.<a class="link"   href="https://blog.csdn.net/weixin_42990464/article/details/113699960" >(44条消息) 基于遥感影像的道路提取论文、开源代码和数据集汇总_点PY的博客-CSDN博客_道路提取
<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="RoadNet"><a href="#RoadNet" class="headerlink" title="RoadNet"></a>RoadNet</h3><h5 id="数据集详细情况-5"><a href="#数据集详细情况-5" class="headerlink" title="数据集详细情况"></a>数据集详细情况</h5><p>我们从谷歌地球收集了加拿大渥太华的几个典型城市地区。图像每像素的空间分辨率为0.21m（缩放级别为19）。<br>Training files:<br>2,3,4,5,6,7,8,9,10,11,12,13,14,15<br>Testing files:<br>1,16,17,18,19,20<br>我们以文件名1为例</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>Ottawa-1.tif</td>
<td>原始图像</td>
</tr>
<tr>
<td>segmentation.png</td>
<td>手动清除路面</td>
</tr>
<tr>
<td>edge.png</td>
<td>手动标注道路边缘</td>
</tr>
<tr>
<td>centerline.png</td>
<td>道路中心线的手动注释</td>
</tr>
<tr>
<td>extra.png</td>
<td>用单个像素宽度的画笔粗略标记异质区域（红色）</td>
</tr>
<tr>
<td>extra-Ottawa-1.tif</td>
<td>覆盖着Ottawa-1.tifextra.png</td>
</tr>
</tbody></table>
<h5 id="数据集下载地址-4"><a href="#数据集下载地址-4" class="headerlink" title="数据集下载地址"></a>数据集下载地址</h5><p>数据集下载： 链接：<a class="link"   href="https://pan.baidu.com/s/1l9RZvyYfLgTOx_k4LQRyhQ" >https://pan.baidu.com/s/1l9RZvyYfLgTOx_k4LQRyhQ<i class="fas fa-external-link-alt"></i></a><br>             提取码：h2zt</p>
<p>出处：1. <a class="link"   href="https://github.com/mitroadmaps/roadtagger" >https://github.com/mitroadmaps/roadtagger<i class="fas fa-external-link-alt"></i></a><br>2.<a class="link"   href="https://blog.csdn.net/weixin_42990464/article/details/113699960" >(44条消息) 基于遥感影像的道路提取论文、开源代码和数据集汇总_点PY的博客-CSDN博客_道路提取<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Generative-Graph-Transformer"><a href="#Generative-Graph-Transformer" class="headerlink" title="Generative Graph Transformer"></a>Generative Graph Transformer</h3><h5 id="数据集详细情况-6"><a href="#数据集详细情况-6" class="headerlink" title="数据集详细情况"></a>数据集详细情况</h5><p>图卢兹道路网络数据集。如果运行该脚本，将下载我们论文中介绍的数据集（图卢兹道路网络数据集）。<br>图卢兹路网数据集，用于从卫星图像的语义分割中提取道路网</p>
<h5 id="数据集下载地址-5"><a href="#数据集下载地址-5" class="headerlink" title="数据集下载地址"></a>数据集下载地址</h5><p>数据集下载： generative-graph-transformer&#x2F;download_dataset.sh at master · davide-belli&#x2F;generative-graph-transformer (github.com)<br>出处：1. <a class="link"   href="https://github.com/davide-belli/generative-graph-transformer" >https://github.com/davide-belli/generative-graph-transformer<i class="fas fa-external-link-alt"></i></a><br>2.<a class="link"   href="https://blog.csdn.net/weixin_42990464/article/details/113699960" >(44条消息) 基于遥感影像的道路提取论文、开源代码和数据集汇总_点PY的博客-CSDN博客_道路提取<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="road-connectivity"><a href="#road-connectivity" class="headerlink" title="road_connectivity"></a>road_connectivity</h3><h5 id="数据集详细情况-7"><a href="#数据集详细情况-7" class="headerlink" title="数据集详细情况"></a>数据集详细情况</h5><p>在本文中，我们提出了一个名为方向学习的连接任务，其动机是人类通过在特定方向跟踪道路来注释道路的行为。我们还开发了一个堆叠的多分支卷积模块，以有效地利用方向学习和分割任务之间的相互信息。</p>
<h5 id="数据集下载地址-6"><a href="#数据集下载地址-6" class="headerlink" title="数据集下载地址"></a>数据集下载地址</h5><p>数据集下载： road_connectivity&#x2F;data at master · anilbatra2185&#x2F;road_connectivity (github.com)<br>出处：1. <a class="link"   href="https://github.com/anilbatra2185/road_connectivity" >https://github.com/anilbatra2185/road_connectivity<i class="fas fa-external-link-alt"></i></a><br>2.(44条消息) 基于遥感影像的道路提取论文、开源代码和数据集汇总_点PY的博客-CSDN博客_道路提取</p>
<h3 id="DeepGlobeRoad"><a href="#DeepGlobeRoad" class="headerlink" title="DeepGlobeRoad"></a>DeepGlobeRoad</h3><h5 id="数据集详细情况-8"><a href="#数据集详细情况-8" class="headerlink" title="数据集详细情况"></a>数据集详细情况</h5><p>比赛数据集包含6226张训练图像，1243张验证图像，以及1101张测试图像。所有的图像尺寸均为1024*1024，图像来源于泰国、印度、印度尼西亚，图像场景包括城市、乡村、荒郊、海滨、热带雨林等多个场景。</p>
<h5 id="数据集下载地址-7"><a href="#数据集下载地址-7" class="headerlink" title="数据集下载地址"></a>数据集下载地址</h5><p>数据集下载： 链接：<a class="link"   href="https://pan.baidu.com/s/1aG1qdTFEcIwzh2YruBGUNA" >https://pan.baidu.com/s/1aG1qdTFEcIwzh2YruBGUNA<i class="fas fa-external-link-alt"></i></a><br>             提取码：podb<br>出处：<a class="link"   href="https://blog.csdn.net/weixin_42990464/article/details/113699960" >(44条消息) 基于遥感影像的道路提取论文、开源代码和数据集汇总_点PY的博客-CSDN博客_道路提取<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>路网识别数据集</category>
      </categories>
      <tags>
        <tag>路网识别</tag>
        <tag>数据集</tag>
      </tags>
  </entry>
  <entry>
    <title>发博文</title>
    <url>/2022/09/19/sendBlog/</url>
    <content><![CDATA[<h3 id="发博文"><a href="#发博文" class="headerlink" title="发博文"></a>发博文</h3><h5 id="1-使用下面命令创建一个md文档"><a href="#1-使用下面命令创建一个md文档" class="headerlink" title="1.使用下面命令创建一个md文档"></a>1.使用下面命令创建一个md文档</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npx hexo new  <span class="string">&quot;页面名称&quot;</span></span><br></pre></td></tr></table></figure>
<p>然后在source_posts中可以找到刚刚创建的文档</p>
<h5 id="写文档"><a href="#写文档" class="headerlink" title="写文档"></a>写文档</h5><p>要实现顶置的文章，需在文章页添加 <code>sticky </code>属性，<code>sticky</code> 值越大，顶置的文章越靠前</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">tile:</span><br><span class="line"><span class="built_in">date</span>:</span><br><span class="line">tages:</span><br><span class="line">categories</span><br><span class="line">sticky: 999</span><br><span class="line">---</span><br><span class="line">在这里开始写博文的正文</span><br></pre></td></tr></table></figure>
<p>博文是用Markdown语言写的，所以你可以用Markdown编辑器。推荐 Haroopad和MaHua</p>
<h5 id="发博文-1"><a href="#发博文-1" class="headerlink" title="发博文"></a>发博文</h5><p>只需要输入三个命令就可以了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx hexo clean</span><br><span class="line">npx hexo generate</span><br><span class="line">git config --global user.name <span class="string">&quot;你的GitHub名字&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;你的GitHub邮箱&quot;</span></span><br><span class="line">(若要本地预览就先执行 hexo server)</span><br><span class="line">npx hexo deploy</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>发博文</tag>
      </tags>
  </entry>
  <entry>
    <title>first one</title>
    <url>/2022/09/19/the-new-day/</url>
    <content><![CDATA[<h2 id="美好的一天从躺平开始！！"><a href="#美好的一天从躺平开始！！" class="headerlink" title="美好的一天从躺平开始！！"></a>美好的一天从躺平开始！！</h2>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>水文</tag>
      </tags>
  </entry>
</search>
